# מטרת הספר
הספר נועד בעיקר למתחילים, אבל גם למתקדמים שרוצים להרחיב את הידע שלהם.  
אמנם יש לנו נטיה כגיקים לרדת לפרטים ולהשתדל להיות "נכון" אבל כאן צריך להשתדל לתת לקורא תחושה שהוא מבין משהו ולא לטבוע בפרטים שלא באמת חשובים להבנת הפרק הבא.  
בשלב הזה לא צריך להקפיד את הסברים ברורים ואפשר להיכנס ולהרחיב איפה שלא צריך, ובהמשך נעשה ניסויים עם מתחילים שונים ונראה את מה צריך לקצץ או אפילו לסלף טיפה העיקר שיהיה קליל.
# היסטוריית כרטיסי ניקוב

במפקדי האוכלוסין שנערכו מדי עשור בארצות הברית מאז לידתה, שיטת הרישום היתה פשוטה. נציגים היו לוקחים מכל אזרח את פרטיו, רושמים את הפרטים על פתק נייר, ושולחים את כל הפתקים למטה המרכזי של המפקד.

באמצע המאה התשע עשרה (1850) האוכלוסייה כמובן גדלה, והספירה הידנית של כל הפתקים נהיית מייגעת ומועדת לטעויות. להוסיף על הכאוס הקיים, הייתה גם דרישה חדשה בקונגרס, לאסוף פרטים נוספים במפקד האוכלוסין, כמו מין, צבע עור, מצב כלכלי ועוד נתונים. וכך, תהליך הספירה באמצעות פתקים הפך להיות כמעט בלתי אפשרי. מנגד, טעות הייתה בלתי אפשרית, שכן הייצוג בקונגרס מבוסס על מפקד האוכלוסין, ולספירה או טעויות בספירה היו משמעויות פוליטיות טעונות.

בשנת 1890+- ממשלת ארה"ב הכריזה על תחרות ליצור תהליך שייעל את הספירה
ההצעה שזכתה הייתה של הרמן הולרית' (Herman Hollerith) שהציג מכונה המבוססת על כרטיסי ניקוב בשם "מכונת טבולציה" (Tabulating machine) 
את הרעיון הוא קיבל מכך שראה בכרטיסי רכבת היה סימון של צבע שיער והמבקר היה מנקב את הכרטיס לפי צבע השיער של הנוסע כדי למנוע העברה של הכרטיס מאדם לאדם.

בשביל מפקד האוכלוסין השתמשו בכרטיס הזה
(ליתר דיוק הכרטיס היה ריק. התמונה היא רק מפה איפה לנקב.)

![image2](/image2.jpg)

הסוקר ניקב את הכרטיס לפי פרטי האזרח.
למשל, הסימון של גבר בן 50 היא ניקוב של האות M ושל המספר 50.


העובד במרכז המיון הכניס את הכרטיס למכונה (בצד שמאל בתמונה הבאה) עם כוסיות עופרת שעמדו מתחת לכל הנקודות בכרטיס ואז הניח מעליו לוח עם מחטים והפעיל את המכונה
במקום שהיה חור המחט נגעה בתושבת שמתחת לכרטיס וסגרה מעגל.
על כל סגירת מעגל המונה של הנקודה הזאת עלה באחד.
כך בתוך זמן קצר אפשר למנות את כל האוכלוסיה של המדינה עם פירוט כמה מתוכם הם גברים/נשים וכו'.
בהמשך הוסיפו מכונת מיון (המכשיר מצד ימין בתמונה הבאה) הכללים היו מובנים מראש
ואם המעגל נסגר בנקודה X התא המיועד נפתח והעובד הכניס את הכרטיס לתוכו.
בהמשך הוסיפו מנגנון שמכניס את כל הכרטיסים באופן אוטומטי בלי צורך שעובד יכניס את הכרטיסים באופן ידני.
 
![image1](/image1.jpg)
 
 אחרי ההצלחה עם ממשלת ארה"ב Herman הקים חברה מסחית שלימים הפכה להיות IBM. לשכות האוכלוסין ממדינות נוספות בעולם עבדו עמו.
והשכיר את המכונות האלו לממשלות שונות וגם לחברות מסחריות.

בהמשך נוספו עוד יכולות כמו מכונה שמנקבת כרטיסים אחרים
ועם לוח בקרה יכלו "לתכנת" את המכונה שתעשה פעולות שונות כשיש מתח בנקודה מסויימת
 
![image3](/image3.jpg)
![image5](/image5.jpg)


הנה תיאור איך מבצעים כפל עם הלוח הזה:
> If I wanted to multiply, say, 12 times 15, I would punch a one and a two into the first column of a card and the second column of a card, then in the third column I would put another one and in the fourth column I would put a five. So the first two spots would be one and two and that would go into place on the plug board that shows it is the multiplier, and then the third and fourth spots on the card would go to a place that showed it was the multiplicand. And then there was a third slot that was to be the result, and that would punch the answer into whichever column on the card you wanted to put it in. And then you would need six wires to complete that.

בשלב מסויים, בגלל שלכל חברה היה צרכים שונים, יצרו לוח גנרי בצורה שאפשרה "לכתוב" על הכרטיס מידע דינמי.
בכל כרטיס היה 80 עמודות ו12 שורות, בכל עמודה אפשר לכתוב תו אחד, כך שיש   80 תווים בכרטיס.
שורות 0-9 חור בכל אחד מהם מסמן את הספרה המתאימה, שורה 11 נקראת X שורה 12 נקראת Y
אם רק Y מנוקב זה מסמן את התו & ואם רק X מנוקב זה מסמן את התו -.
הABC  חולק ל3 קבוצות וסומן עם 2 ניקובים.
למשל 12+1=A
12+2=B
11+1=J
וכן הלאה.
0+9=Z
השורה 0 שימשה גם כסמן וגם שסימון לספרה 0

![image4](/image4.png)

אין ספק שיש כאן הרבה בזבוז של מקום על הדף, למה לסמן רק עם 2 ניקובים כשאפשר ליצור עוד הרבה סוגי שילובים, בשביל לייצר עוד סוגי תווים בפחות מקום?

במשך השנים עברו לשמירת המידע על חומרים אחרים, שאפשרו לשמור יותר מידע על כל ס"מ, וגם לכתוב ולמחוק ללא הגבלה.
היצוג של חור מנוקב או לא, בוצע על ידי כתיבה של 0 ו 1.
חור=דלוק=1 בלי חור=כבוי=0

למשל, סרט מגנטי: מגנט שפונה למעלה=1 למטה=0.
או חורים בדיסק, ומחט עוברת על הדיסק ו"קוראת" איפה יש חורים.
כיום שומרים את המידע בתאים קטנים, שאפשר לטעון אותם בשדה מגנטי. אבל הרעיון הבסיסי נשאר זהה:ל המידע נשמר ב0 או 1.

בשנות ה60 הגיעו לסטנדרט של שמירת מידע (צריך להרחיב יותר בסיפור הזה)
וקבעו שלכל נקודת מידע קוראים ביט (bit) ולכל שמונה ביטים קוראים בייט (byte).


בשונה מהשיטה של IBM לעיל שלא מנצלת את כל הצירופים שאפשר לשמור
כאן יצרו סטנדרט שבו אפשר לנצל את כל הצירופים
החשבון פשוט ב8 ביט אפשר לשמור עד 256
בא נתחיל מחשבון של 2 ביט בו אפשר לשמור 4 צירופים
00=0
01=1
10=2
11= 3
עכשיו כל ביט שמוסיפים מכפיל את האפשרויות ב2 
אם יש לנו 3 ביט אז יש לנו 8 צרופים
כל הצירופים שהיה לנו עם 2 ביטים עם 0 בהתחלה או עם 1 בהתחלה
```
000=0
010=1
010=2
011=3
100=4
110=5
110=6
111=7
```
וכן הלאה

```
4=16
5=32
6=64
7=128
8=256
```
אז בבייט אנחנו יכולים לשמור מספר עד 255
או לשמור טקסט, איך נשמור טקסט?
מסכמים על לוח האותיות
וכל אות מקבלת מספר כך למשל האות A מסומנת עם המספר 65
בהמשך רצו להוסיף עוד אותיות משפות אחרות ובגלל שאין מקום בייצוג של 8 ביט שומרים את המידע בשני בייטים שזה 16 ביט שנותן 256X256 אפשרויות (למי שאין כח לחשב זה יוצא 65536 אפשרויות)


לשיטת ייצוג זו קוראים חשבון בינארי
אפשר לעשות חשבון בדומה לחשבון שעושים בחשבון עשרוני (מה שאנחנו משתמשים ביום יום)
למשל אם רוצים לעשות את החשבון הבא
 01101101
+
0000001
אז 1+1=0 עם שארית 1
ואז 0+0+שארית 1 = 1
וכן הלאה
וכך יוצאים עם התוצאה 
01101110

כדי להמיר מספר בינארי לעשרוני
צריך לחשב שהמספר הראשון שווה 1 השני 2 השלישי 4 הרביעי 8 וכן הלאה
ולכן 01101110 שווה 2+4+8+32+64.

אחרי שהבנו איך זה מתבצע על הנייר צריך לנסות איך המחשב עושה את זה.


הבסיס של המעבד זה שערים לוגיים 
שזה רכיב שכיום עשוי לרוב מסיליקון שיש לו שתי כניסות ויציאה אחת
יש כמה סוגי שערים
OR זה שער שיוציא זרם אם הוא מקבל זרם באחד משני הכניסות (או בשניהם?)
XOR זה שער דומה לOR אבל הוא לא יוציא זרם אם יש זרם בשני הכניסות
AND זה שער שמוציא זרם רק אם הוא מקבל זרם בשני הכניסות.

בשביל לעשות חישוב חיבור פשוט (בלי שארית) אז אפשר להעביר את הביט הראשון של שני הבייטים שרוצים לחשב דרך שער OR והפלט נרשם במקום בו רוצים לשמור את הביט הראשון של התוצאה, וכן הלאה.
הבעיה היא כמובן שאנחנו רוצים לשמור את השארית
בשביל זה אפשר להשתמש בHalf Adder (חצי מחבר)
שמורכב משני שערים
השער הראשון XOR מחשב את הקלט של שני הביטים
אם זה 0+1 הפלט יהיה 1
אם זה 0+0או 1+1 הפלט יהיה 0
בנוסף נעביר את הקלט של שני הביטים דרך שער AND 
והפלט שלו ישמר באוגר מיוחד של השארית.
ורק במקרה של 1+1 הפלט שלו יהיה 1.
עכשיו הבעיה היא שבביט הבא אנחנו צריכים לחשב חשבון עם 3 מקורות שני המספרים + השארית.
ושבפלט יהיה 
בשביל זה יש מבנה קצת יותר מורכב של שערים בשם full-adder
(לא יודע האם יש תועלת להכנס לכל החשבון של full-adder הרעיון הובן)

אנימציה של  Half Adder מויקיפדיה
![Halfadder](https://upload.wikimedia.org/wikipedia/commons/9/92/Halfadder.gif)

אנימציה של  full-adder מויקיפדיה
![Fulladder](https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)


אחרי שיש לנו אמצעי אחסון כל שהוא ומעבד המורכב משערים לוגיים אפשר לחשב כל חישוב כשהקלט והפלט יכול להיות אמצעי אחסון שונים.

במחשב המודרני יש אמצעי אחסון לטווח ארוך (דיסק קשיח) ואמצעי אחסון לטווח קצר.
 באחסון בדיסק אפשר לשמור מידע לכתיבה בלבד ע"י סימון חורים בנקודות שונות בדיסק והמחט עולה ויורדת לפי החורים, בדיסק עם אפשרות למחיקה (לא יודע איך זה עובד) אפשר לבטל את הסימונים האלו.
באחסון RAM (ר"ת של Random Access Memory [זיכרון גישה אקראית]) יש טבלה של תאים שבהם אפשר לטעון מטעןc מגנטי ולסמן 1 עם מטען 0 בלי מטען (תתקנו אותי אם אני טועה).

החסרון באחסון בדיסק זה המהירות קריאה\כתיבה
והחסרון באחסון בRAM הוא שהמידע נמחק כשהמחשב נכבה (דהיינו שאין מתח) ובנוסף הרכיבים של RAM הרבה יותר יקרים מדיסק.

במעבדים מודרניים יש גם זיכרון RAM צמוד למעבד לגישה מהירה המכונה רג'יסטר 

# שפת אסמבלי

שפת אסמבלי היא שפת התכנות הנמוכה ביותר והכי קרובה למעבד, בין שפת אסמבלי לבין הפקודות שרצות בפועל על המעבד נמצא רק ה'אסמבלר' (בלועזית assembler) שתפקידו הוא להמיר את הפקודות שכתובת בשפת אסמבלי למספרים בינאריים שהמעבד מריץ אותם כפקודות. כל עבודה עם שפת אסמבלי חייבת להיות בתיאום מושלם עם סוג המעבד שעליו מריצים את הפקודות, זה הסיבה שכדי לכתוב בשפת אסמבלי זה קריטי להבין את אופן הפעולה של המעבד ואת כל הרכיבים שהוא משתמש בהם.

הפקודה הבסיסית ביותר בשפת אסמבלי היא `mov`. 

הפקודה mov מעתיקה ערך מסוים ומציבה אותו במקום מסוים, לדוגמא:

``` assembly
mov ax, 5
```

בדוגמא הזאת המשמעות היא לקחת את הספרה 5 ולהציב אותה ברגיסטר `ax`. (סדר האופרטורים הוא מימין לשמאל)

## מה הם אוגרים (רגיסטרים)?
https://github.com/ynigun/open-book/issues/8

אוגרים הנקראים בשמם הלועזי Registers, הם סוג של זיכרון מיוחד המשמש את המעבד ברוב הפעולות, הזיכרון של הרגיטרים הוא מיוחד בכך שהוא נמצא בתוך המעבד עצמו וזמן הגישה של המעבד אליהם מוגדר כ-'אפס זמן' (zero wait), הרגיטרים בכלליות משמשים את המעבד בכל הפעולות שלו, לדוגמא כדי לכתוב ערך מסוים לזיכרון (RAM) המעבד לא מציב את הערך ישירות בזיכרון אלא תחילה מציב אותו בתוך אחד הרגיטרים ולאחר מכן מעתיק את הערך של הרגיסטר לזיכרון.

הגודל של הרגיסטרים נקבע לפי הדור של המעבד, במעבד 32 ביטים הוא בגודל של 32 ביטים, וכן הלאה, ובעצם כשאומרים מעבד בעל 32 סיביות, הכוונה הוא למעבד שגודל הרגיסטרים שלו הם 32 ביטים.

רגיסטרים נפוצים: `ax` `bx` `cx` `dx` `bp` `sp` וכן הלאה

אגב, השמות של הרגיסטרים הללו הם מדגם מעבד ישן שלא קיים כיום (16-Bit), בגירסת המעבדים של 32 ביטים מוסיפים בהתחלה את האות `e` לדוג' `eax`, `ebx` וכן הלאה, ובמעבדים של 64 ביטים מוסיפים בהתחלה את האות `r` לדוג' `rax`, `abx`.


פקודה נוספת בשפת אסמבלי היא: `add`.

הפקודה `add` מקבלת 2 אופרנדים, היא לוקחת את האופרנד הראשון ומוסיפה אותו לאופרנד השני ומציבה את התוצאה באופרנד השני. לדוגמא:
``` assembly
add bx, 5
```

בדוגמא הזאת המשמעות היא לקחת את הספרה 5, לקחת את הערך שנמצא ברגיסטר 'bx' ולהוסיף לו את המספר הנ"ל (5), לאחר מכן להציב את התוצאה ברגיסטר `bx`.

## שפות עיליות
מכיוון שזה מורכב לכתוב תוכנות באסמבלי המציאו שפות שיותר קלות לקריאה לבני אדם
ובאמצעות תוכנה הנקראת 'קומפיילר' ממירים את הפקודות לשפת מכונה, אחרי ההמרה קשה לשחזר את הקוד המקורי מתוך הקוד בשפת מכונה, אבל יש כלים שעוזרים לעשות את זה באופן חלקי על ידי שהם מציגים את קוד האסמבלי של התוכנית, כך אפשר להבין מה התוכנה מבצעת.

יש 2 סוגים של שפות עיליות   
1) שפות מקופלות 
שבהם הקומפיילר ממיר את כל הקוד לשפת מכונה 
2) שפות מפורשות  
שבהם יש מנוע שממיר את הקוד לשפת מכונה בזמן אמת, שפות אלו יותר איטיים מאשר המקומפלות אבל מצד שני יותר גמישים בכתיבה ולא מוגבלים לכללים הנוקשים של השפות המקומפלות.

כיום יש הרבה שפות עיליות עם יתרונות וחסרונות לכל שפה אבל באופן כללי יש כמה עקרונות שיש כמעט בכל שפה.
* משתנים - אפשרות לתת שמות לערכים שונים (לדוגמה a=1)
* חשבון- חיבור/חיסור/חילוק/הכפלה (לדוגמה b=a+1)
* תנאים - יצירת תנאי להרצת פעולה מסויימת לרוב עם המילה מפתח if ("אם" באנגלית) (לדוגמה if b==2)
בשפת C ועוד כותבים את הקוד שרץ במצב שהתנאי במתקיים בתוך סוגריים {}    
* פונקציות - כדי לחסוך את העבודה של כתיבה של אותו קוד הרבה פעמים אפשר ליצור פונקציה ולהשתמש בה במספר מקומות, ולהגדיר את המשתנים בפונקציה באופן דינמי.
* לולאות - לא קיימת בכל השפות, אבל זו דרך נפוצה לחזור על אותה פעולה סך פעמים (ולהגדיר את מספר הפעמים עם משתנה)  
* מערכים - רשימה של משתנים, צורה נוחה לעיבוד מידע בעולם האמיתי, למשל קובץ CSV הוא בעצם מערך של שורות של שורה היא מערך של משתנים, כך שאם אני רוצה את שורה 7 אני יכול לשלוף את זה בצורה כזאת mycsv[7] ואם אני רוצה את עמודה 3 בשורה 7 mycsv[7][3], ברוב השפות אפשר לקבל ערך ממערך וגם לכתוב אליו, כך שאפשר לערוך את הקובץ CSV שלנו בקלות.  
 אם אני רוצה לחפש משהו במערך אני יכול לקבל את אורך המערך באמצעות פונקציה מובנית ברוב השפות ואז לעבור על כל האיברים במערך ולבכל איבר לבדוק האם הערך שווה למה שאני מחפש.

## מערכות הפעלה
כיוון שאנחנו רוצים להריץ מספר תוכנות על אותו מחשב יש צורך בתוכנה שתריץ אותם והתוכנה הזאת מכונה מערכת הפעלה
(הקטע הבא נכתב ע"י copilot אין לי מושג האם הקוד נכון או לא)
כשמשתמשים במערכת הפעלה  אי אפשר לגשת לחומר ישירות וכדי לפתוח קובץ למשל משתמשים בsystem call שמפעילה פונקציה במערכת הפעלה שקוראת את התוכן של הקובץ ומחזירה את התוצאה למשתמש.

בassmbly פתיחת קובץ נראית ככה:
```
mov rax, 2
mov rdi, filename
mov rsi, 0
mov rdx, 0
syscall
```
שמים את סוג הפעולה ברגיסטר rax, את הפרמטרים ברגיסטרים rdi, rsi, rdx ומפעילים את הפעולה בsyscall

אבל ברוב השפות העיליות זה הרבה יותר פשוט וקריא יותר טוב, למשל בפייתון זה נראה ככה:
```
file = open(filename)
print(file.read())
```
כלומר יש פונקציה שנקראת open שמקבלת את השם של הקובץ ומחזירה את הקובץ ואז יש פונקציה שנקראת read שמקבלת את הקובץ ומחזירה את התוכן שלו.

במערכת הפעלה לינוקס כל החומרה של המחשב מיוצגת כקבצים
זאת אומרת אם רוצים להשמיע משהו ברמקול מעתיקים לקובץ יעודי והמערכת הפעלה לוקחת את כל מה שנכתב לשם ומעבירה לחומרה של הרמקול

כנ"ל עם המסך, המקלדת וכו'

כדי לקבל את המקשים שהמשתמש מקליד במקלדת בודקים את הקובץ של המקלדת ומקבלים את התוכן שלו
גם זה ברוב השפות העיליות עטוף בפונקציות נוחות יותר כמו input() בפייתון כככה שאתה לא צריכים לעבוד קשה ולדעת איך להתחבר לחומרה בכל מערכת הפעלה.


## מערכות קבצים
בדיסק אפשר לכתוב הרבה ביטים אבל אם אנחנו רוצים קבצים אנחנו צריכים מערכת שתסמן איפה מתחיל ונגמר כל קובץ, חלוקה לתיקיות וכדו'


מערכת קבצים היא שיטה לארגון וניהול קבצים על גבי מדיה לאחסון כמו דיסק קשיח. 

מערכת הקבצים מגדירה את האופן שבו המידע נשמר כקבצים ותיקיות, כיצד מזהים ומאתרים אותם וכיצד ניגשים אליהם.

מערכת הקבצים צריכה לטפל במספר דרישות מרכזיות:

**ארגון המידע לקבצים ותיקיות** - הגדרת מבנה היררכי של תיקיות וקבצים שבו ניתן לאחסן את המידע.

**שמות קבצים** - מתן שם ייחודי לכל קובץ ותיקייה כך שניתן יהיה לזהות אותם. 

**גישה לקבצים** - יכולת לקרוא, לכתוב, לעדכן ולמחוק קבצים. גישה זו יכולה להיות מוגבלת על פי הרשאות.

**ניהול מקום פנוי** - עקב מחיקת קבצים נוצרים "חורים" במקומות שונים על הדיסק, מערכת הקבצים צריכה "לדחוס" ולנהל את המקום הפנוי. 

**אבטחת מידע** - הגנה על המידע מפני גישה לא מורשית או שיבושים.

**שחזור מידע** - יכולת לשחזר מידע שאבד עקב תקלות למשל.

דוגמאות למערכות קבצים נפוצות הן FAT, NTFS בחלונות, ext4 בלינוקס ו-APFS במקינטוש.

מערכת הקבצים היא חלק קריטי בכל מערכת הפעלה, מאחר והיא מאפשרת את ניהול המידע והקבצים על גבי מדיות האחסון.

## רשתות
רשת האינטרנט זה רשת של מחשבים שיוכלים לשלוח ולקבל מידע מהאחד לשני

אפשר לעשות רשת מקומית בבית ואפשר לעשות רשת גלובלית עם כל המחשבים בעולם

כל מחשב ברשת צריך להיות מזהה ייחודי כדי שהמחשבים האחרים יוכלו להבדיל ביניהם

כל מחשב ברשת צריך להיות מחובר למחשב אחר כדי שהמחשבים יוכלו לשלוח ולקבל מידע

# כתובת IP

כל מחשב ברשת צריך להיות מזהה ייחודי כדי שהמחשבים האחרים יוכלו להבדיל ביניהם

כיום האינטרנט בנוי בעיקר על פרוטוקול IP
שזה ר"ת של Internet Protocol

כל מחשב ברשת צריך להיות מחובר למחשב אחר כדי שהמחשבים יוכלו לשלוח ולקבל מידע
לכל מחשב יש כתובת IP ייחודית  
כתובת IP זה מספר שלם בן 32 ביטים
כלומר יש 2^32 כתובות IP שונות
שזה כמעט 4 מיליארד כתובות IP

הכתובות נעות בין 0.0.0.0 ל255.255.255.255
למה 255? כי זה המספר הגדול ביותר שאפשר לכתוב ב8 ביטים

כל כתובת IP מורכבת מ4 חלקים של 8 ביטים

כל חלק נקרא אוקטט
כל אוקטט יכול להיות בין 0 ל255

ברשת יש צמתים שמחוברים זה לזה באמצאות כבלים וכל צומת צריך להיות מחובר לצומת אחר כדי שהמחשבים יוכלו לשלוח ולקבל מידע
כשמחשב שולח מידע הוא שולח את המידע לכתובת הIP של המקבל
הוא שולח הודעה כזו:
```
כתובת השולח: 1.1.1.1
כתובת המקבל: 2.2.2.2
גודל ההודעה: 1000 ביטים
גוף ההודעה: "שלום"
```
(בפועל לא צריך לכתוב "כתובת השולח" פשוט יש הסכמה שה32 ביטים הראשונים הם כתובת השולח וכן הלאה)

הוא שולח את ההודעה לראוטר שלו
והראוטר שלו שולח את ההודעה לראוטר הבא
והראוטר הבא שולח את ההודעה לראוטר הבא
עד שההודעה מגיעה לראוטר של המקבל

בכל ראוטר יש טבלת כתובות IP
והטבלה הזאת מכילה כתובת IP וכתובת MAC
כתובת MAC זה מספר שלם בן 48 ביטים
כלומר יש 2^48 כתובות MAC שונות
שזה כמעט 300 טריליון כתובות MAC

הMAC היא הכתובת הפיזית של המכשיר שמחובר לראוטר
(לא יודע האם MAC קשור לכאן בכלל)


  ככה כשההודעה מגיעה לראוטר הראשון הוא יודע שהוא צריך לשלוח את ההודעות שמיועדות לכתובת שמתחילה ב2 לראוטר/מחשב מסויים
כשההודעה מדיעה לראוטר השני הוא מעביר את ההודעה לראוטר שרשום אצלו שאמור לקבל את ההודעות שמיודעות לכתובות שמתחילות ב2.2
וכן הלאה עד שמגיע לראוטר של המקבל.

כשהנמען רוצה לענות הוא עונה לכתובת ממנו הוא קיבל את ההודעה

# פורטים 
 כדי שהמחשב יוכל לתקשר עם מספר מחשבים בו זמנית
יש פורטים

כל פורט יכול להיות בין 0 ל65535

  ומספר הפורט מתווסף להודעה שנשלחת וככה המקבל יודע לאיזה פורט לשלוח את התשובה
אז ככה נראה ההודעה שנשלחת:
```
כתובת השולח: 1.1.1.1
פורט השולח: 1234
כתובת המקבל: 2.2.2.2
פורט המקבל: 5678
גודל ההודעה: 1000 ביטים
גוף ההודעה: "שלום"
```

וכש2.2.2.2 מקבל את ההודעה הוא יודע שהוא צריך להחזיר את התשובה לפורט 5678

  מקובל לכתוב את הפורט עם נקודותיים בין הכתובת לפורט
1.1.1.1:1234
2.2.2.2:5678


כשהתוכנה שולחת את ההודעה הוא יודע שהוא אמור לקבל תשובה בפורט 1234 לכן התוכנה מתחילה להאזין לפורט 1234  
  האזנה זה פשוט לקרוא את ההודעות שמגיעות לקובץ שמשוייך לפורט 1234
כשההודעה תגיע התוכנה תקרא אותה ותעשה איתה משהו.  
המערכת הפעלה דוגאת שלא יהיו שתי תכונות שמאזינות לאותו פורט ולכן כשהתוכנה תנסה להאזין לפורט שהוא כבר נמצא בשימוש המערכת הפעלה תחזיר שגיאה

אם אנחנו רוצים להפעיל תוכנה שמקבלת הודעות ומגיבה להם
אנחנו נצטרך להגדיר לה פורט ולהגדיר לה פונקציה שתקרא את ההודעות שמגיעות לפורט הזה
ותגיב לכתובת:פורט ממנו נשלח ההודעה

למשל אם אנשחנו רוצים לתת למשתמשים שירות של שעון  
התוכנה שלנו תאזין בפורט 1234 ותקבל הודעות מכל העולם
ואם ההודעה מכיל את המילים מה השעה ותחזיר את השעה של השעון בשרת שלנו

הקוד שלנו יראה משהו כזה
``` 
for{
// לולואה אינסופית
// כל פעם שמגיעה הודעה חדשה התוכנה תקרא אותה ותגיב לה

newMessage = getMessageFromPort(1234)
snentFrom = getSentFrom(newMessage)
MessageBody = getMessageBody(newMessage)
if MessageBody == "get time"{
    sendMessage(
        sentFrom: "1.1.1.1:1234",
        sentTo: snentFrom,
        messageBody:  "the time is: 12:00"
    )
    }
    // אחרי שהתוכנה תשלח את ההודעה היא תחזור להאזין לפורט 1234
    }
```
# tcp

TCP ו-UDP הם שני פרוטוקולי תקשורת שמשמשים להעברת מידע בין מחשבים ברשת.

ההבדל המרכזי ביניהם הוא ש-TCP יוצר תחילה חיבור בין שני הצדדים לפני שליחת מידע, ולאחר מכן שולח את המידע במנות קטנות ומאשר קבלה של כל מנה. אם איזו מנה לא הגיעה כראוי, TCP יבקש לשלוח אותה מחדש. 

לעומת זאת, UDP פשוט שולח את כל המידע בבת אחת ללא חיבור מוקדם או אישורי קבלה. אין שום וידוא שהמידע הגיע בשלמותו ליעד.

יתרונות TCP:
- אמינות - כל המידע מגיע במלואו
- סדר - המידע מגיע באותו סדר שנשלח

יתרונות UDP:  
- מהירות - אין צורך להמתין לאישורים ולכן זה מהיר יותר
- פשטות - זה פרוטוקול פשוט יותר למימוש 

לכן, TCP מתאים יותר ליישומים שדורשים אמינות כמו דפדפנים, דוא"ל, העברת קבצים. UDP מתאים יותר ליישומים של שמע ווידאו בזמן אמת שם מהירות חשובה יותר מאמינות.

הסבר על מה זה "מנות" בהקשר ל-TCP.

כש-TCP שולח מידע, הוא לא שולח אותו כיחידה אחת גדולה, אלא מחלק אותו לחתיכות קטנות יותר הנקראות מנות (packets). 

לדוגמה, אם TCP צריך לשלוח לך קובץ של 100 מגה-בייט, הוא יחלק אותו למנות של 1 קילו-בייט כל אחת. כל מנה נשלחת בנפרד ו-TCP מקבל אישור על כל מנה שהגיעה בהצלחה.

יתרונות של חלוקה למנות:

- אם מנה אחת אבדה או השתבשה, צריך לשלוח רק אותה מנה מחדש במקום את כל המידע.

- זה מאפשר ל-TCP לווסת את קצב השליחה ולהגביל את מספר המנות הנשלחות בכל פעם כדי למנוע עומס יתר ברשת.

- בגלל המנות הקטנות, קל יותר לנתב אותן ברשת לעומת יחידה גדולה אחת.

אז בתמצית - TCP שולח את המידע בחתיכות קטנות שנקראות מנות כדי לאפשר שליטה ובקרה טובה יותר על תהליך העברת המידע ברשת.

# NAT
כיום יש מחסור בכתובות IP לכן יש כתובות IP פרטיות 
דהיינו שלספק יש כתובת IP ציבורית וללקוחות שלו הוא מחלק כתובות IP פרטיות

NAT או Network Address Translation הוא מנגנון שמאפשר לחלק כתובות IP פנימיות פרטיות בתוך רשת מקומית, תוך שימוש בכתובת IP ציבורית אחת כלפי חוץ.

הסיבות המרכזיות לשימוש ב-NAT הן:

**מחסור בכתובות IP** - יש מחסור בכתובות IP ציבוריות זמינות. עם NAT אפשר לתת לכל מחשב ברשת פנימית כתובת IP פרטית ולהשתמש בכתובת ציבורית אחת לכל הרשת.

**אבטחה** - NAT מסתיר את הרשת הפנימית מאחורי כתובת IP אחת. זה מונע גישה ישירה מבחוץ למחשבים ברשת הפנימית.

**גמישות** - NAT מאפשר שינוי תצורת הרשת הפנימית מבלי לשנות את ההגדרות ברשת החיצונית.

עקרון הפעולה של NAT:

כשמחשב ברשת הפנימית שולח בקשת HTTP למשל לשרת באינטרנט, הוא שולח אותה עם כתובת ה-IP הפרטית שלו כמקור. 

ה-NAT בנתב מקבל את הבקשה, מחליף את כתובת המקור בכתובת ה-IP הציבורית של הנתב ושולח הלאה את הבקשה. 

כאשר מגיעה תשובה חזרה מהשרת, ה-NAT שומר מיפוי בין כתובת ה-IP הפרטית לבין הבקשה, כך שהוא יכול להעביר את התשובה בחזרה למחשב המתאים ברשת הפנימית.

כך NAT מאפשר לכל מחשב ברשת פנימית לתקשר עם האינטרנט גם אם יש לרשת רק כתובת IP ציבורית אחת.

# היסטוריה של האינטרנט

# מבנה של הרשת כתובות IP

# הצפנת תעבורה

כשאנחנו שולחים מידע באינטרנט כמו סיסמה או פרטי כרטיס אשראי, אנחנו רוצים שרק הצד המקבל יוכל לקרוא את המידע הזה ואף אחד אחר.

אבל המידע עובר בכבלים וצמתים של האינטרנט שגורמים אחרים יכולים לצותת להם. אז איך נמנע מאחרים לקרוא את המידע?

פה נכנסת הצפנה - לפני שליחת המידע אנחנו "מבלבלים" אותו באופן מתמטי מורכב כך שהוא הופך לג'יבריש שאף אחד לא יכול לקרוא. 

רק כשהמידע מגיע למקבל, יש לו "מפתח" מיוחד שמאפשר לו לפענח את הבלבול ולהפוך את המידע בחזרה לקריא.

אז גם אם מישהו ציתת למידע המוצפן בדרך, הוא לא יוכל לקרוא אותו כי הוא מוצפן. רק המקבל יכול לפענח אותו עם המפתח שלו.

זו בעצם הרעיון של הצפנת תעבורה - להפוך את המידע לג'יבריש מוצפן שרק הצדדים הרלוונטיים יכולים לקרוא.

ההבדל בין הצפנה סימטרית להצפנה אסימטרית:

**הצפנה סימטרית** משתמשת באותו מפתח הצפנה הן להצפנה והן לפענוח. כלומר, אותו מפתח משמש גם את השולח וגם את המקבל. 

לדוגמה, אם המפתח הוא המילה "סודי" - השולח משתמש במילה סודי כדי להצפין, והמקבל משתמש באותה מילה כדי לפענח.

**הצפנה אסימטרית** משתמשת בזוג מפתחות שונים להצפנה ולפענוח:

- מפתח ציבורי להצפנה
- מפתח פרטי לפענוח

לדוגמה, השולח מצפין עם המפתח הציבורי של המקבל, והמקבל מפענח עם המפתח הפרטי שלו.

המפתחות הפרטי והציבורי קשורים מתמטית, אך אי אפשר לגזור אחד מהשני.

יתרונות של הצפנה אסימטרית:

- מפתח פרטי לא צריך להיות משותף
- קל יותר לנהל מפתחות במערכות גדולות 
- טובה יותר מבחינת אבטחה

לכן היא נפוצה יותר היום ביישומי הצפנה מודרניים.

בהצפנה אסימטרית יש שני מפתחות:

1. מפתח ציבורי (Public Key) 

2. מפתח פרטי (Private Key)

המפתח הציבורי מפורסם לכולם. המפתח הפרטי ידוע רק למשתמש.

כעת נדמיין שאני רוצה לשלוח לך הודעה סודית:

1. אני משתמש במפתח הציבורי שלך כדי להצפין את ההודעה.

2. המידע המוצפן נשלח אליך. 

3. רק אתה יכול להשתמש במפתח הפרטי שלך כדי לפענח את ההודעה.

4. אף אחד אחר לא יכול לפענח אותה כי אין להם את המפתח הפרטי שלך.

5. כדי לענות לי, אתה משתמש במפתח הציבורי שלי להצפנה. 

6. רק אני יכול לפענח את התשובה עם המפתח הפרטי שלי.

זה מאפשר תקשורת מאובטחת ומאומתת בין שני צדדים. זו בעצם הרעיון מאחורי הצפנה אסימטרית.


# ההבדל בין TCP/UDP

# היסטוריה של הדפדפן

# קצת על המורכבות של הדפדפן

# סקירה של HTML+CSS+JS

# מה קורה בפועל כשאני נכנס לאתר דרך הדפדפן
DNS  
TCP  
TLS  
SNI  
HTTP  
WS  

# מסדי נתונים
SQL
NoSQL
SQLite
KV
# אבטחת מידע
# DDOS
# SQLi
