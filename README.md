# היסטוריית כרטיסי ניקוב

במפקדי האוכלוסין שנערכו מדי עשור בארצות הברית מאז לידתה, שיטת הרישום היתה פשוטה. נציגים היו לוקחים מכל אזרח את פרטיו, רושמים את הפרטים על פתק נייר, ושולחים את כל הפתקים למטה המרכזי של המפקד.

באמצע המאה התשע עשרה (1850) האוכלוסייה כמובן גדלה, והספירה הידנית של כל הפתקים נהיית מייגעת ומועדת לטעויות. להוסיף על הכאוס הקיים, הייתה גם דרישה חדשה בקונגרס, לאסוף פרטים נוספים במפקד האוכלוסין, כמו מין, צבע עור, מצב כלכלי ועוד נתונים. וכך, תהליך הספירה באמצעות פתקים הפך להיות כמעט בלתי אפשרי. מנגד, טעות הייתה בלתי אפשרית, שכן הייצוג בקונגרס מבוסס על מפקד האוכלוסין, ולספירה או טעויות בספירה היו משמעויות פוליטיות טעונות.

בשנת 1890+- ממשלת ארה"ב הכריזה על תחרות ליצור תהליך שייעל את הספירה
ההצעה שזכתה הייתה של הרמן הולרית' (Herman Hollerith) שהציג מכונה המבוססת על כרטיסי ניקוב בשם "מכונת טבולציה" (Tabulating machine) 
את הרעיון הוא קיבל מכך שראה בכרטיסי רכבת היה סימון של צבע שיער והמבקר היה מנקב את הכרטיס לפי צבע השיער של הנוסע כדי למנוע העברה של הכרטיס מאדם לאדם.

בשביל מפקד האוכלוסין השתמשו בכרטיס הזה
(ליתר דיוק הכרטיס היה ריק. התמונה היא רק מפה איפה לנקב.)

![image2](/image2.jpg)

הסוקר ניקב את הכרטיס לפי פרטי האזרח.
למשל, הסימון של גבר בן 50 היא ניקוב של האות M ושל המספר 50.


העובד במרכז המיון הכניס את הכרטיס למכונה (בצד שמאל בתמונה הבאה) עם כוסיות עופרת שעמדו מתחת לכל הנקודות בכרטיס ואז הניח מעליו לוח עם מחטים והפעיל את המכונה
במקום שהיה חור המחט נגעה בתושבת שמתחת לכרטיס וסגרה מעגל.
על כל סגירת מעגל המונה של הנקודה הזאת עלה באחד.
כך בתוך זמן קצר אפשר למנות את כל האוכלוסיה של המדינה עם פירוט כמה מתוכם הם גברים/נשים וכו'.
בהמשך הוסיפו מכונת מיון (המכשיר מצד ימין בתמונה הבאה) הכללים היו מובנים מראש
ואם המעגל נסגר בנקודה X התא המיועד נפתח והעובד הכניס את הכרטיס לתוכו.
בהמשך הוסיפו מנגנון שמכניס את כל הכרטיסים באופן אוטומטי בלי צורך שעובד יכניס את הכרטיסים באופן ידני.
 
![image1](/image1.jpg)
 
 אחרי ההצלחה עם ממשלת ארה"ב Herman הקים חברה מסחית שלימים הפכה להיות IBM. לשכות האוכלוסין ממדינות נוספות בעולם עבדו עמו.
והשכיר את המכונות האלו לממשלות שונות וגם לחברות מסחריות.

בהמשך נוספו עוד יכולות כמו מכונה שמנקבת כרטיסים אחרים
ועם לוח בקרה יכלו "לתכנת" את המכונה שתעשה פעולות שונות כשיש מתח בנקודה מסויימת
 
![image3](/image3.jpg)
![image5](/image5.jpg)


הנה תיאור איך מבצעים כפל עם הלוח הזה:
> If I wanted to multiply, say, 12 times 15, I would punch a one and a two into the first column of a card and the second column of a card, then in the third column I would put another one and in the fourth column I would put a five. So the first two spots would be one and two and that would go into place on the plug board that shows it is the multiplier, and then the third and fourth spots on the card would go to a place that showed it was the multiplicand. And then there was a third slot that was to be the result, and that would punch the answer into whichever column on the card you wanted to put it in. And then you would need six wires to complete that.

בשלב מסויים, בגלל שלכל חברה היה צרכים שונים, יצרו לוח גנרי בצורה שאפשרה "לכתוב" על הכרטיס מידע דינמי.
בכל כרטיס היה 80 עמודות ו12 שורות, בכל עמודה אפשר לכתוב תו אחד, כך שיש   80 תווים בכרטיס.
שורות 0-9 חור בכל אחד מהם מסמן את הספרה המתאימה, שורה 11 נקראת X שורה 12 נקראת Y
אם רק Y מנוקב זה מסמן את התו & ואם רק X מנוקב זה מסמן את התו -.
הABC  חולק ל3 קבוצות וסומן עם 2 ניקובים.
למשל 12+1=A
12+2=B
11+1=J
וכן הלאה.
0+9=Z
השורה 0 שימשה גם כסמן וגם שסימון לספרה 0

![image4](/image4.png)

אין ספק שיש כאן הרבה בזבוז של מקום על הדף, למה לסמן רק עם 2 ניקובים כשאפשר ליצור עוד הרבה סוגי שילובים, בשביל לייצר עוד סוגי תווים בפחות מקום?

במשך השנים עברו לשמירת המידע על חומרים אחרים, שאפשרו לשמור יותר מידע על כל ס"מ, וגם לכתוב ולמחוק ללא הגבלה.
היצוג של חור מנוקב או לא, בוצע על ידי כתיבה של 0 ו 1.
חור=דלוק=1 בלי חור=כבוי=0

למשל, סרט מגנטי: מגנט שפונה למעלה=1 למטה=0.
או חורים בדיסק, ומחט עוברת על הדיסק ו"קוראת" איפה יש חורים.
כיום שומרים את המידע בתאים קטנים, שאפשר לטעון אותם בשדה מגנטי. אבל הרעיון הבסיסי נשאר זהה:ל המידע נשמר ב0 או 1.

בשנות ה60 הגיעו לסטנדרט של שמירת מידע (צריך להרחיב יותר בסיפור הזה)
וקבעו שלכל נקודת מידע קוראים ביט (bit) ולכל שמונה ביטים קוראים בייט (byte).


בשונה מהשיטה של IBM לעיל שלא מנצלת את כל הצירופים שאפשר לשמור
כאן יצרו סטנדרט שבו אפשר לנצל את כל הצירופים
החשבון פשוט ב8 ביט אפשר לשמור עד 256
בא נתחיל מחשבון של 2 ביט בו אפשר לשמור 4 צירופים
00=0
01=1
10=2
11= 3
עכשיו כל ביט שמוסיפים מכפיל את האפשרויות ב2 
אם יש לנו 3 ביט אז יש לנו 8 צרופים
כל הצירופים שהיה לנו עם 2 ביטים עם 0 בהתחלה או עם 1 בהתחלה
```
000=0
010=1
010=2
011=3
100=4
110=5
110=6
111=7
```
וכן הלאה

```
4=16
5=32
6=64
7=128
8=256
```
אז בבייט אנחנו יכולים לשמור מספר עד 255
או לשמור טקסט, איך נשמור טקסט?
מסכמים על לוח האותיות
וכל אות מקבלת מספר כך למשל האות A מסומנת עם המספר 65
בהמשך רצו להוסיף עוד אותיות משפות אחרות ובגלל שאין מקום בייצוג של 8 ביט שומרים את המידע בשני בייטים שזה 16 ביט שנותן 256X256 אפשרויות (למי שאין כח לחשב זה יוצא 65536 אפשרויות)


לשיטת ייצוג זו קוראים חשבון בינארי
אפשר לעשות חשבון בדומה לחשבון שעושים בחשבון עשרוני (מה שאנחנו משתמשים ביום יום)
למשל אם רוצים לעשות את החשבון הבא
 01101101
+
0000001
אז 1+1=0 עם שארית 1
ואז 0+0+שארית 1 = 1
וכן הלאה
וכך יוצאים עם התוצאה 
01101110

כדי להמיר מספר בינארי לעשרוני
צריך לחשב שהמספר הראשון שווה 1 השני 2 השלישי 4 הרביעי 8 וכן הלאה
ולכן 01101110 שווה 2+4+8+32+64.

אחרי שהבנו איך זה מתבצע על הנייר צריך לנסות איך המחשב עושה את זה.


הבסיס של המעבד זה שערים לוגיים 
שזה רכיב שכיום עשוי לרוב מסיליקון שיש לו שתי כניסות ויציאה אחת
יש כמה סוגי שערים
OR זה שער שיוציא זרם אם הוא מקבל זרם באחד משני הכניסות (או בשניהם?)
XOR זה שער דומה לOR אבל הוא לא יוציא זרם אם יש זרם בשני הכניסות
AND זה שער שמוציא זרם רק אם הוא מקבל זרם בשני הכניסות.

בשביל לעשות חישוב חיבור פשוט (בלי שארית) אז אפשר להעביר את הביט הראשון של שני הבייטים שרוצים לחשב דרך שער OR והפלט נרשם במקום בו רוצים לשמור את הביט הראשון של התוצאה, וכן הלאה.
הבעיה היא כמובן שאנחנו רוצים לשמור את השארית
בשביל זה אפשר להשתמש בHalf Adder (חצי מחבר)
שמורכב משני שערים
השער הראשון XOR מחשב את הקלט של שני הביטים
אם זה 0+1 הפלט יהיה 1
אם זה 0+0או 1+1 הפלט יהיה 0
בנוסף נעביר את הקלט של שני הביטים דרך שער AND 
והפלט שלו ישמר באוגר מיוחד של השארית.
ורק במקרה של 1+1 הפלט שלו יהיה 1.
עכשיו הבעיה היא שבביט הבא אנחנו צריכים לחשב חשבון עם 3 מקורות שני המספרים + השארית.
ושבפלט יהיה 
בשביל זה יש מבנה קצת יותר מורכב של שערים בשם full-adder
(לא יודע האם יש תועלת להכנס לכל החשבון של full-adder הרעיון הובן)

אנימציה של  Half Adder מויקיפדיה
![Halfadder](https://upload.wikimedia.org/wikipedia/commons/9/92/Halfadder.gif)

אנימציה של  full-adder מויקיפדיה
![Fulladder](https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)


אחרי שיש לנו אמצעי אחסון כל שהוא ומעבד המורכב משערים לוגיים אפשר לחשב כל חישוב כשהקלט והפלט יכול להיות אמצעי אחסון שונים.

במחשב המודרני יש אמצעי אחסון לטווח ארוך (דיסק קשיח) ואמצעי אחסון לטווח קצר.
 באחסון בדיסק אפשר לשמור מידע לכתיבה בלבד ע"י סימון חורים בנקודות שונות בדיסק והמחט עולה ויורדת לפי החורים, בדיסק עם אפשרות למחיקה (לא יודע איך זה עובד) אפשר לבטל את הסימונים האלו.
באחסון RAM (ר"ת של Random Access Memory [זיכרון גישה אקראית]) יש טבלה של תאים שבהם אפשר לטעון מטעןc מגנטי ולסמן 1 עם מטען 0 בלי מטען (תתקנו אותי אם אני טועה).

החסרון באחסון בדיסק זה המהירות קריאה\כתיבה
והחסרון באחסון בRAM הוא שהמידע נמחק כשהמחשב נכבה (דהיינו שאין מתח) ובנוסף הרכיבים של RAM הרבה יותר יקרים מדיסק.

במעבדים מודרניים יש גם זיכרון RAM צמוד למעבד לגישה מהירה המכונה רג'יסטר 

# שפת אסמבלי

שפת אסמבלי היא שפת התכנות הנמוכה ביותר והכי קרובה למעבד, בין שפת אסמבלי לבין הפקודות שרצות בפועל על המעבד נמצא רק ה'אסמבלר' (בלועזית assembler) שתפקידו הוא להמיר את הפקודות שכתובת בשפת אסמבלי למספרים בינאריים שהמעבד מריץ אותם כפקודות. כל עבודה עם שפת אסמבלי חייבת להיות בתיאום מושלם עם סוג המעבד שעליו מריצים את הפקודות, זה הסיבה שכדי לכתוב בשפת אסמבלי זה קריטי להבין את אופן הפעולה של המעבד ואת כל הרכיבים שהוא משתמש בהם.

הפקודה הבסיסית ביותר בשפת אסמבלי היא `mov`. 

הפקודה mov מעתיקה ערך מסוים ומציבה אותו במקום מסוים, לדוגמא:

``` assembly
mov ax, 5
```

בדוגמא הזאת המשמעות היא לקחת את הספרה 5 ולהציב אותה ברגיסטר `ax`. (סדר האופרטורים הוא מימין לשמאל)

## מה הם אוגרים (רגיסטרים)?
https://github.com/ynigun/open-book/issues/8

אוגרים הנקראים בשמם הלועזי Registers, הם סוג של זיכרון מיוחד המשמש את המעבד ברוב הפעולות, הזיכרון של הרגיטרים הוא מיוחד בכך שהוא נמצא בתוך המעבד עצמו וזמן הגישה של המעבד אליהם מוגדר כ-'אפס זמן' (zero wait), הרגיטרים בכלליות משמשים את המעבד בכל הפעולות שלו, לדוגמא כדי לכתוב ערך מסוים לזיכרון (RAM) המעבד לא מציב את הערך ישירות בזיכרון אלא תחילה מציב אותו בתוך אחד הרגיטרים ולאחר מכן מעתיק את הערך של הרגיסטר לזיכרון.

הגודל של הרגיסטרים נקבע לפי הדור של המעבד, במעבד 32 ביטים הוא בגודל של 32 ביטים, וכן הלאה, ובעצם כשאומרים מעבד בעל 32 סיביות, הכוונה הוא למעבד שגודל הרגיסטרים שלו הם 32 ביטים.

רגיסטרים נפוצים: `ax` `bx` `cx` `dx` `bp` `sp` וכן הלאה

אגב, השמות של הרגיסטרים הללו הם מדגם מעבד ישן שלא קיים כיום (16-Bit), בגירסת המעבדים של 32 ביטים מוסיפים בהתחלה את האות `e` לדוג' `eax`, `ebx` וכן הלאה, ובמעבדים של 64 ביטים מוסיפים בהתחלה את האות `r` לדוג' `rax`, `abx`.


פקודה נוספת בשפת אסמבלי היא: `add`.

הפקודה `add` מקבלת 2 אופרנדים, היא לוקחת את האופרנד הראשון ומוסיפה אותו לאופרנד השני ומציבה את התוצאה באופרנד השני. לדוגמא:
``` assembly
add bx, 5
```

בדוגמא הזאת המשמעות היא לקחת את הספרה 5, לקחת את הערך שנמצא ברגיסטר 'bx' ולהוסיף לו את המספר הנ"ל (5), לאחר מכן להציב את התוצאה ברגיסטר `bx`.

## שפות עיליות
מכיוון שזה מורכב לכתוב תוכנות באסמבלי המציאו שפות שיותר קלות לקריאה לבני אדם
ובאמצעות תוכנה הנקראת 'קומפיילר' ממירים את הפקודות לשפת מכונה, אחרי ההמרה קשה לשחזר את הקוד המקורי מתוך הקוד בשפת מכונה, אבל יש כלים שעוזרים לעשות את זה באופן חלקי על ידי שהם מציגים את קוד האסמבלי של התוכנית, כך אפשר להבין מה התוכנה מבצעת.

יש 2 סוגים של שפות עיליות   
1) שפות מקופלות 
שבהם הקומפיילר ממיר את כל הקוד לשפת מכונה 
2) שפות מפורשות  
שבהם יש מנוע שממיר את הקוד לשפת מכונה בזמן אמת, שפות אלו יותר איטיים מאשר המקומפלות אבל מצד שני יותר גמישים בכתיבה ולא מוגבלים לכללים הנוקשים של השפות המקומפלות.

כיום יש הרבה שפות עיליות עם יתרונות וחסרונות לכל שפה אבל באופן כללי יש כמה עקרונות שיש כמעט בכל שפה.
* משתנים - אפשרות לתת שמות לערכים שונים (לדוגמה a=1)
* חשבון- חיבור/חיסור/חילוק/הכפלה (לדוגמה b=a+1)
* תנאים - יצירת תנאי להרצת פעולה מסויימת לרוב עם המילה מפתח if ("אם" באנגלית) (לדוגמה if b==2)
בשפת C ועוד כותבים את הקוד שרץ במצב שהתנאי במתקיים בתוך סוגריים {}    
* פונקציות - כדי לחסוך את העבודה של כתיבה של אותו קוד הרבה פעמים אפשר ליצור פונקציה ולהשתמש בה במספר מקומות, ולהגדיר את המשתנים בפונקציה באופן דינמי.
* לולאות - לא קיימת בכל השפות, אבל זו דרך נפוצה לחזור על אותה פעולה סך פעמים (ולהגדיר את מספר הפעמים עם משתנה)  
* מערכים - רשימה של משתנים, צורה נוחה לעיבוד מידע בעולם האמיתי, למשל קובץ CSV הוא בעצם מערך של שורות של שורה היא מערך של משתנים, כך שאם אני רוצה את שורה 7 אני יכול לשלוף את זה בצורה כזאת mycsv[7] ואם אני רוצה את עמודה 3 בשורה 7 mycsv[7][3], ברוב השפות אפשר לקבל ערך ממערך וגם לכתוב אליו, כך שאפשר לערוך את הקובץ CSV שלנו בקלות.  
 אם אני רוצה לחפש משהו במערך אני יכול לקבל את אורך המערך באמצעות פונקציה מובנית ברוב השפות ואז לעבור על כל האיברים במערך ולבכל איבר לבדוק האם הערך שווה למה שאני מחפש.

## מערכות הפעלה
כיוון שאנחנו רוצים להריץ מספר תוכנות על אותו מחשב יש צורך בתוכנה שתריץ אותם והתוכנה הזאת מכונה מערכת הפעלה

## מערכות קבצים
בדיסק אפשר לכתוב הרבה ביטים אבל אם אנחנו רוצים קבצים אנחנו צריכים מערכת שתסמן איפה מתחיל ונגמר כל קובץ, חלוקה לתיקיות וכדו'

# מסדי נתונים
SQL
NoSQL
SQLite
KV
## רשתות

# היסטוריה של האינטרנט

# מבנה של הרשת כתובות IP

# הצפנת תעבורה

# ההבדל בין TCP/UDP

# היסטוריה של הדפדפן

# קצת על המורכבות של הדפדפן

# סקירה של HTML+CSS+JS

# מה קורה בפועל כשאני נכנס לאתר דרך הדפדפן
DNS  
TCP  
TLS  
SNI  
HTTP  
WS  

# אבטחת מידע
# DDOS
# SQLi
